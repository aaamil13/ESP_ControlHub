# EspHub Project

EspHub е гъвкав хъб за домашна автоматизация, базиран на ESP32, който използва ESP-NOW за бърза локална комуникация и MQTT за интеграция с по-големи системи като Home Assistant.

## Архитектура

Проектът се състои от две основни части:
1.  **EspHubLib**: Библиотека, която предоставя основната функционалност на хъба.
2.  **Примери**: Демонстрационни проекти, които показват как да се използва библиотеката (напр. `examples/EspDevice`).

## PLC JSON Схема

PLC логиката се конфигурира чрез JSON обект, изпратен по MQTT на тема `esphub/config/plc`. Конфигурацията се състои от следните елементи:

*   **`watchdog_timeout_ms`**: (Опционално) Време в милисекунди, след което, ако PLC задачата не отговори, устройството ще се рестартира. По подразбиране е 5000.
*   **`memory`**: Блок за деклариране на променливи.
*   **`init`**: (Опционално) Блок с еднократни действия, които се изпълняват при стартиране на PLC програмата, за да се зададе начално състояние.
*   **`logic`**: Блок за описване на цикличната логическа мрежа.
*   **`applications`**: Блок за конфигуриране на високо-ниво приложни модули.

### 1. Блок `memory`

Този блок декларира всички променливи, които ще се използват в PLC програмата.

```json
"memory": {
  "име_на_променлива_1": { "type": "тип", "retentive": false },
  "име_на_променлива_2": { "type": "тип", "retentive": true }
}
```

*   **`име_на_променлива`**: Уникално име на променливата.
*   **`type`**: Тип на данните. Поддържани стойности: `bool`, `byte`, `int`, `dint`, `real`, `string`.
*   **`retentive`**: `true` или `false`. Ако е `true`, стойността на променливата ще се запазва след рестарт на хъба.

### 2. Блок `init` (Опционален)

Този блок дефинира списък от действия, които се изпълняват **еднократно** при стартиране на PLC програмата. Той е идеален за задаване на безопасно начално състояние на изходите.

```json
"init": [
  {
    "action": "set_value",
    "variable": "switch.living_room.heater",
    "value": false
  },
  {
    "action": "set_value",
    "variable": "switch.garden.valve",
    "value": false
  }
]
```
*   **`action`**: Тип на действието. Засега се поддържа само `set_value`.
*   **`variable`**: Името на променливата от `memory` блока, чиято стойност ще се зададе.
*   **`value`**: Началната стойност.

### 3. Блок `logic`

Този блок описва **циклично изпълняваната** логическа мрежа, като свързва променливи с входовете и изходите на функционални блокове.

```json
"logic": [
  {
    "block_type": "AND",
    "inputs": {
      "in1": "име_на_входна_променлива_1",
      "in2": "име_на_входна_променлива_2"
    },
    "outputs": {
      "out": "име_на_изходна_променлива"
    }
  },
  {
    "block_type": "TON",
    "inputs": {
      "in": "име_на_входна_променлива",
      "pt": 5000 
    },
    "outputs": {
      "q": "име_на_изходна_променлива",
      "et": "име_на_променлива_за_текущо_време"
    }
  }
]
```

*   **`block_type`**: Тип на функционалния блок (напр. `AND`, `OR`, `NOT`, `TON` - таймер със закъснение при включване).
*   **`inputs`**: Обект, който свързва входовете на блока с имена на променливи от `memory` блока или с константни стойности.
*   **`outputs`**: Обект, който свързва изходите на блока с имена на променливи от `memory` блока.

### Пълен пример

```json
{
  "memory": {
    "sensor.living_room.motion": { "type": "bool" },
    "switch.living_room.light": { "type": "bool" },
    "light_on_timer_q": { "type": "bool" },
    "light_on_timer_et": { "type": "dint" }
  },
  "logic": [
    {
      "block_type": "TON",
      "inputs": {
        "in": "sensor.living_room.motion",
        "pt": 300000 
      },
      "outputs": {
        "q": "light_on_timer_q"
      }
    },
    {
      "block_type": "OR",
      "inputs": {
        "in1": "sensor.living_room.motion",
        "in2": "light_on_timer_q"
      },
      "outputs": {
        "out": "switch.living_room.light"
      }
    }
  ]
}
```
В този пример, лампата в хола (`switch.living_room.light`) ще се включи, ако сензорът за движение (`sensor.living_room.motion`) се активира **ИЛИ** ако таймерът (`light_on_timer_q`) все още е активен. Таймерът се стартира от сензора за движение и поддържа лампата включена 5 минути (300000 ms) след последното отчетено движение.

### 3. Блок `applications`

Този блок позволява на потребителите да инстанцират и конфигурират предефинирани, високо-ниво модули, без да се налага да пишат PLC логика.

```json
"applications": [
  {
    "type": "thermostat",
    "config": {
      "temp_sensor": "sensor.living_room.temperature",
      "heater_output": "switch.living_room.heater",
      "setpoint": 22.5
    }
  },
  {
    "type": "irrigation",
    "config": {
      "valve_output": "switch.garden.valve",
      "duration_minutes": 15,
      "start_time": "22:00"
    }
  }
]
```

*   **`type`**: Името на приложния модул (напр. `thermostat`, `irrigation`).
*   **`config`**: Обект със специфични за модула настройки.